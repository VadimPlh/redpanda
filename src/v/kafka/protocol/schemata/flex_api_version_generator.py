# Copyright 2022 Redpanda Data, Inc.
#
# Use of this software is governed by the Business Source License
# included in the file licenses/BSL.md
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0

#
# Flexible version code generator for kafka API
# =============================================
#
# Much of the work with flexible versions depends on there being a mapping of
# each API to the first version that it had introduced flex support.
#
# This program creates these lookup tables for other C++ and python programs
# to consume
#
# For more information on flex, PR cover letter:
# https://github.com/redpanda-data/redpanda/pull/4513
#

import io
import sys
import os
import json
import pathlib
import jinja2

# The only request that is never flexible is sasl_handshake_request - 17
never_flexible = -1

# Not every value from 0 -> max_api_key is a valid request, non-supported
# requests will map to a value of api_version(-2)
invalid_api = -2


class VersionRange:
    """
    A version range is fundamentally a range [min, max] but there are several
    different ways in the kafka schema format to specify the bounds.
    """
    def __init__(self, spec):
        self.min, self.max = self._parse(spec)

    def _parse(self, spec):
        match = re.match("^(?P<min>\d+)$", spec)
        if match:
            min = int(match.group("min"))
            return min, min

        match = re.match("^(?P<min>\d+)\+$", spec)
        if match:
            min = int(match.group("min"))
            return min, None

        match = re.match("^(?P<min>\d+)\-(?P<max>\d+)$", spec)
        if match:
            min = int(match.group("min"))
            max = int(match.group("max"))
            return min, max


def parse_schema(schema):
    s = io.StringIO()
    with open(schema, 'r') as f:
        for line in f.readlines():
            line = re.sub("\/\/.*", "", line)
            if line.strip():
                s.write(line)

    return json.loads(s.getvalue())


def parse_version(f):
    assert pathlib.Path(f).suffix == '.json'
    schema = parse_schema(f)
    assert schema is not None
    api_key = schema["apiKey"]
    assert api_key is not None
    flex = schema['flexibleVersions']
    assert flex is not None
    if flex == "none":
        flex = never_flexible
    else:
        r = VersionRange(flex)
        flex = r.min
    return api_key, flex


def write_versions_cpp(flex_version_map, outfile):
    """
    For better performance generate code as a flat static array
    """
    assert len(flex_version_map) > 0
    max_api_key = -1
    for api_key, api_version in flex_version_map.items():
        max_api_key = max(max_api_key, api_key)
    arr_mapping = [invalid_api for _ in range(0, max_api_key + 1)]
    for api_key, api_version in flex_version_map.items():
        arr_mapping[api_key] = api_version

    cpp_template = """#pragma once
#include <array>
#include "kafka/types.h"

// autogenerated file - do not manually edit
//
// The following std::array contains a mapping between each kafka api request
// where the api key is the index into this array which maps to the corresponding
// first version for which flex support was introduced for that request.

namespace kafka {
class flex_versions {
public:
    static constexpr bool is_flexible_request(api_key key, api_version version) {
        const api_version first_flex_version = _flex_mapping.at(key());
        return (version >= first_flex_version) && (first_flex_version != never_flexible);
    }

    static constexpr bool is_api_in_schema(api_key key) noexcept {
        constexpr auto max_version = _flex_mapping.max_size() - 1;
        if(key() < 0 || static_cast<size_t>(key()) > max_version) {
            return false;
        }
        const api_version first_flex_version = _flex_mapping.at(key());
        return first_flex_version != invalid_api;
    }


private:
    /// The only request that is never flexible is sasl_handshake_request - 17
    static constexpr inline api_version never_flexible = api_version({{ never_flexible }});

    /// Not every value from 0 -> max_api_key is a valid request, non-supported
    /// requests will map to a value of api_key({{ invalid_api }})
    static constexpr inline api_version invalid_api = api_version({{ invalid_api }});

    static constexpr std::array<api_version, {{ length }}> _flex_mapping{
{%- for value in flex_version_arr %}
      api_version({{ value }}),
{%- endfor %}
    };
};
}
"""

    with open(outfile, 'w') as f:
        f.write(
            jinja2.Template(cpp_template).render(flex_version_arr=arr_mapping,
                                                 never_flexible=never_flexible,
                                                 invalid_api=invalid_api,
                                                 length=len(arr_mapping)))


def write_versions_py(flex_version_map, outfile):
    py_template = """#!/usr/bin/env python3

# autogenerated file - do not manually edit
#
# The following dictionary contains a mapping between each kafka api request/response
# key and the corresponding first version for which flex support was introduced

# The only request that is never flexible is sasl_handshake_request - 17
never_flexible = {{ never_flexible }}

flex_versions = {
{%- for key, value in flex_version_map.items() %}
  {{ key }}:{{ value }},
{%- endfor %}
}

def is_flexible_request(key, version):
    first_flex = flex_versions[key]
    return (version >= first_flex) and (first_flex != never_flexible)

def is_api_in_schema(key):
    return key in flex_versions

"""

    assert len(flex_version_map) > 0
    with open(outfile, 'w') as f:
        f.write(
            jinja2.Template(py_template).render(
                flex_version_map=flex_version_map,
                never_flexible=never_flexible))


if __name__ == "__main__":
    assert len(sys.argv) >= 4
    src_dir = sys.argv[1]  # directory this source should exist in
    out_dir = sys.argv[2]  # where result files are written to
    filename = sys.argv[3]  # result file prefix
    schemas = sys.argv[4:]  # list of all kafka schema files
    schemas = [os.path.join(src_dir, s) for s in schemas]
    flex_api_versions = {}
    for f in schemas:
        api_key, flex = parse_version(f)
        eflex = flex_api_versions.get(api_key, None)
        assert eflex is None or eflex == flex
        flex_api_versions[api_key] = flex

    cpp_hdr = os.path.join(out_dir, filename + '.h')
    py_src = os.path.join(out_dir, filename + '.py')
    write_versions_cpp(flex_api_versions, cpp_hdr)
    write_versions_py(flex_api_versions, py_src)
